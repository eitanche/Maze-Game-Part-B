<?xml version="1.0" encoding="UTF-8"?>

<?import java.net.*?>
<?import javafx.scene.control.*?>

<ScrollPane fx:id="scrollPane" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="400.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/10.0.2-internal" xmlns:fx="http://javafx.com/fxml/1" fx:controller="View.AboutWindow">
   <content>
         <Label fx:id="aboutLabel" styleClass="unique" alignment="TOP_CENTER" maxWidth="540.0" minWidth="180.0" prefWidth="360.0" text="This game was created by Ehud Malul and Eitan Chertok, 2nd year students at the Software and Information Systems Engineering department in Ben Gurion University. We built this game as a project in the Advanced Topics in Programming course. We programmed the game in Java, using JavaFX for designing the GUI. First, we implemented a maze generation algorithm, using the DFS algorithm. Maze is represented by a 2D array of ones and zeroes – zero is for a passage(sea), and one is for a wall(sand). In the generation algorithm, a neighbour of a specific cell, is a cell which is distanced 1 cell away from it. The algorithm first starts with a 2D array of walls, and chooses a random start position – which is turned to a passage, and set to be the current position.  Then, at each step of the algorithm, it chooses a random wall neighbour of the current position. The algorithm breaks the new chosen wall, and the wall between the current position and the neighbour. Then the current position is set to the new chosen neighbour. This step is repeated until every cell of the maze that was visited, doesn’t have a wall neighbour. The next step of the project was to implement 3 algorithms for solving the maze: DFS, BFS, and Best First Search – which finds the solution with the cheapest price. We implemented these algorithms while keeping the SOLID principles. We also used the Strategy Design Pattern to allow adding more solving algorithms and similar puzzles easily (such as 8-Puzzle, Maze3D and more) – without changing the current code. After that, we created new Streams for compressing and decompressing the maze, using the Decorator Design Pattern. These Streams are built on top of another Stream. Compressor is built on top of an output stream. The Compressor compresses the maze and writes it to the output stream. Decompressor is built on top of an input stream. The decompressor reads from the input stream the compressed maze, and then decompresses it. The simple algorithm compresses each maximal sequence of same numbers to one byte. The second algorithm, compresses every 8 cells to one byte. Later, we designed a client – server model, using the Strategy Design Pattern. We created 2 Servers – one that receives from the client sizes for a maze, generates it and sends it back to the client. The second server receives from the client a maze, solves it and saves the solution. Then it sends the solution back to the client. We used the Strategy Design Pattern to allow adding servers and clients with different functionality, without changing the current code. The server we created is multithreaed – it can handle more than one client concurrently. We designs the server’s functionality so they will be thread safe. We also created a configuration file for the program, using Singleton Design Pattern, so there will be only one instance of the file. The configuration file is used to change the program properties, such as the thread pool size, the searching algorithm and the maze generation algorithm. Finally, we created a GUI for our game, using the MVVM architecture. The View manages all the user interface logic and the graphics of the program. The Model manages all the business logic – generating the maze, moving the player and more. The View Model intermediates between the View and the Model, and validates the input from the user. We designed this architecture using the Observer Design Pattern. While creating this game, we learnt a lot about Object Oriented Programming. We designed the project using the SOLID principles and a few design patterns, such as: Observer, Singleton, Factory, Strategy and more. We also experienced designing a GUI."
 textAlignment="CENTER" wrapText="true" />

   </content>

   <stylesheets>
      <URL value="@style" />
   </stylesheets>
</ScrollPane>
